use std::fs::File;
use std::io::prelude::*;
use std::io::BufReader;

use ark_bls12_381::Fq as Fbls12_381;
use ark_ff::BigInt as arkBigInt;
use ark_ff::PrimeField;
use ark_std::str::FromStr;
use core::str;

use num_bigint::BigInt;
use num_traits::Num;

#[derive(Clone)]
pub struct Constants<T: PrimeField> {
    pub c: Vec<T>,           //round constants
    pub m: Vec<Vec<T>>,      //MDS matrix
    pub t: usize,            //width of the state
    pub partial_rounds: u32, //number of partial rounds
    pub full_rounds: u32,    //number of full rounds
    pub alpha: u32,          //exponent of the S-box
}

/*********************************************************
Padding function for an input vector.
The functions pads input with 0s and returns a vector
that is a multiple of r. If the length of the input is a
multiple of r, then no padding takes place.
*********************************************************/
pub fn pad<T: PrimeField>(input: &Vec<T>, r: u32) -> Vec<T> {
    let mut padded_input: Vec<T> = input.to_vec();

    while padded_input.len() as u32 % r != 0 {
        padded_input.push(T::ZERO);
    }

    padded_input
}

/*********************************************************
Implements the poseidon permutation.
*********************************************************/
pub fn poseidon_permutation<T: PrimeField>(state: Vec<T>, constants: &mut Constants<T>) -> Vec<T> {
    let mut new_state = state.to_vec();

    for _i in 0..constants.full_rounds {
        ark(&mut new_state, constants);
        sbox(&mut new_state, constants.clone(), true);
        linear_layer(&mut new_state, constants.clone());
    }
    for _i in 0..constants.partial_rounds {
        ark(&mut new_state, constants);
        sbox(&mut new_state, constants.clone(), false);
        linear_layer(&mut new_state, constants.clone());
    }
    for _i in 0..constants.full_rounds {
        ark(&mut new_state, constants);
        sbox(&mut new_state, constants.clone(), true);
        linear_layer(&mut new_state, constants.clone());
    }

    new_state
}

/*********************************************************
Executes de linear layer.
Multiplies the MDS matrix times the state
*********************************************************/
fn linear_layer<T: PrimeField>(state: &mut Vec<T>, constants: Constants<T>) {
    let mut result: Vec<T> = Vec::new();
    init_state(&mut result, constants.t);

    for i in 0..constants.t {
        for j in 0..constants.t {
            result[i].add_assign(state[j] * constants.m[i][j]);
        }
    }
    *state = result.clone();
}

/*********************************************************
Executes the S-box stage
Computes for each element in the state x^alpha
*********************************************************/
fn sbox<T: PrimeField>(state: &mut Vec<T>, constants: Constants<T>, full: bool) {
    if full {
        // apply full s-box
        for i in 0..state.len() {
            let p: arkBigInt<1> = arkBigInt::from(constants.alpha);
            state[i] = state[i].pow(p);
        }
    } else {
        // apply partial s-box
        let p: arkBigInt<1> = arkBigInt::from(constants.alpha);
        state[0] = state[0].pow(p);
    }
}

/*********************************************************
Executes the ARK stage. Deletes each round constant
that gets multiplied.
*********************************************************/
fn ark<T: PrimeField>(state: &mut Vec<T>, constants: &mut Constants<T>) {
    for i in 0..state.len() {
        state[i].add_assign(constants.c[0]);
        constants.c.remove(0);
    }
}

/*********************************************************
Initialize a state vector
**********************************************************/
fn init_state<T: PrimeField>(state: &mut Vec<T>, t: usize) {
    state.clear();
    for _i in 0..t {
        state.push(T::ZERO);
    }
}

/********************************************************
Reads the round constants and MDS matriz from the
given file_name generated by the sage subrutine.
This function read files in the output format of
https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/generate_parameters_grain.sage
 *********************************************************/
pub fn read_constants_bls12381() -> Constants<Fbls12_381> {
    /*
    # GF(p), alpha=5, N = 1275, n = 255, t = 5, R_F = 8, R_P = 60: sage generate_parameters_grain.sage 1 0 255 5 8 60 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001
     */
    let file = File::open("bls12_381_constants.txt").expect("file not found");
    let reader = BufReader::new(file);

    let mut c: Vec<Fbls12_381> = Vec::new();
    let mut m: Vec<Vec<Fbls12_381>> = Vec::new();

    let mut i = 0;

    for line in reader.lines() {
        // line 2 contains the round constants
        if i == 2 {
            let mut rconst: String = line.unwrap().replace(" ", "").replace("'", "");
            rconst.pop();
            rconst.remove(0);

            let constants: Vec<&str> = rconst.split(',').collect();
            for constant in constants {
                //all constants in the file are writen in hex and need to be converted to dec
                let n = BigInt::from_str_radix(&constant[2..], 16).unwrap();
                let number: Fbls12_381 = Fbls12_381::from_str(&n.to_string()).unwrap();
                c.push(number);
            }
            i += 1;
        }
        // line 15 contains the mds matrix
        else if i == 15 {
            let mut mds = line.unwrap().replace(" ", "").replace("'", "");
            mds.pop();
            mds.pop();
            mds.remove(0);
            mds.remove(0);
            let rows: Vec<&str> = mds.split("],[").collect();

            for r in rows {
                let rows_vector: Vec<&str> = r.split(",").collect();
                let mut mi: Vec<Fbls12_381> = Vec::new();
                for r2 in rows_vector {
                    //all constants in the file are writen in hex and need to be converted to dec
                    let n2 = BigInt::from_str_radix(&r2[2..], 16).unwrap();
                    let v2: Fbls12_381 = Fbls12_381::from_str(&n2.to_string()).unwrap();
                    mi.push(v2);
                }
                m.push(mi);
            }
            i += 1;
        }
        i += 1;
    }

    Constants {
        c,
        m,
        t: 5,
        partial_rounds: 60,
        full_rounds: 8,
        alpha: 5,
    }
}

/********************************************************
Tests
 *********************************************************/
#[cfg(test)]
mod poseidon_permutation {
    use crate::*;
    use ark_std::UniformRand;

    #[test]
    fn padd_test() {
        let state: Vec<Fbls12_381> = vec![
            Fbls12_381::from(1),
            Fbls12_381::from(2),
            Fbls12_381::from(3),
            Fbls12_381::from(4),
            Fbls12_381::from(5),
            Fbls12_381::from(6),
            Fbls12_381::from(7),
            Fbls12_381::from(8),
        ];

        let new_state = pad(&state, 3);

        assert_eq!(new_state.len(), 9);
    }

    #[test]
    fn ark_test() {
        let mut constants = read_constants_bls12381();
        let mut state: Vec<Fbls12_381> = Vec::new();
        let mut result: Vec<Fbls12_381> = Vec::new();
        let mut rng = ark_std::test_rng();

        constants.c.clear();

        for i in 0..constants.t {
            state.push(Fbls12_381::rand(&mut rng));
            constants.c.push(Fbls12_381::rand(&mut rng));
            result.push(state[i] + constants.c[i]);
        }

        ark(&mut state, &mut constants);
        assert_eq!(state, result);
    }
}
